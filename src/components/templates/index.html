<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WhisperX - Audio Transcription</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Additional styling -->
    <style>
        .dropzone {
            border: 2px dashed #4a5568;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
        }

        .dropzone.highlight {
            border-color: #4299e1;
            background-color: rgba(66, 153, 225, 0.1);
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left: 4px solid #4299e1;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .timestamp {
            color: #4a5568;
            font-size: 0.85rem;
        }

        .speaker {
            font-weight: bold;
            color: #2b6cb0;
        }

        .word:hover {
            background-color: rgba(66, 153, 225, 0.2);
            border-radius: 0.25rem;
        }
    </style>
</head>

<body class="bg-gray-100 min-h-screen font-sans">
    <div class="container mx-auto px-4 py-8">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold text-gray-800">WhisperX Transcription</h1>
            <p class="text-gray-600">Drop your audio file to transcribe with word-level timestamps</p>
        </header>

        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <form id="upload-form" class="space-y-4">
                <div class="dropzone p-12 text-center" id="drop-area">
                    <input type="file" id="file-input" name="file" accept="audio/*,video/*" class="hidden">
                    <div class="text-gray-500">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto mb-2" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                        <p class="text-lg font-medium">Drag & drop your audio file here</p>
                        <p class="text-sm">or <span class="text-blue-500 cursor-pointer" id="browse-files">browse
                                files</span></p>
                        <p class="text-xs mt-2 text-gray-400">Supported formats: MP3, WAV, M4A, etc.</p>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <!-- Backend selection - only shown on Apple Silicon -->
                    <div id="backend-container" class="{{ 'hidden' if not is_apple_silicon }}">
                        <label for="backend" class="block text-sm font-medium text-gray-700 mb-1">Backend</label>
                        <select id="backend" name="backend"
                            class="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            <option value="whisperx">WhisperX (CPU mode, with speaker diarization)</option>
                            <option value="mlx">Lightning Whisper MLX (Optimized for Apple Silicon, no diarization)
                            </option>
                        </select>
                        <p class="text-xs mt-1 text-gray-500">
                            MLX is optimized for Apple Silicon and much faster, but doesn't support speaker diarization.
                        </p>
                    </div>

                    <!-- Model selection -->
                    <div>
                        <label for="model_name" class="block text-sm font-medium text-gray-700 mb-1">Model Size</label>
                        <select id="model_name" name="model_name"
                            class="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            <option value="tiny">tiny (fastest, least accurate)</option>
                            <option value="base">base</option>
                            <option value="small">small</option>
                            <option value="medium">medium</option>
                            <option value="large-v2" selected>large-v2 (slowest, most accurate)</option>
                            <option value="large-v3">large-v3 (newest model)</option>
                            <!-- MLX specific distilled models will be shown dynamically -->
                        </select>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <label for="language" class="block text-sm font-medium text-gray-700 mb-1">Language
                            (optional)</label>
                        <select id="language" name="language"
                            class="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            <option value="">Auto-detect</option>
                            <option value="en">English</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="es">Spanish</option>
                            <option value="it">Italian</option>
                            <option value="ja">Japanese</option>
                            <option value="zh">Chinese</option>
                            <option value="ru">Russian</option>
                            <option value="pt">Portuguese</option>
                            <option value="ar">Arabic</option>
                        </select>
                    </div>

                    <div id="max-speakers-container">
                        <label for="max_speakers" class="block text-sm font-medium text-gray-700 mb-1">Max
                            Speakers</label>
                        <input type="number" id="max_speakers" name="max_speakers" value="2" min="1" max="10"
                            class="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                        <p id="diarization-note" class="hidden text-xs mt-1 text-yellow-600">
                            Note: Speaker diarization not available with MLX backend
                        </p>
                    </div>

                    <div>
                        <label for="compute_type" class="block text-sm font-medium text-gray-700 mb-1">Compute
                            Type</label>
                        <select id="compute_type" name="compute_type"
                            class="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            <option value="float16">float16 (Best for Apple Silicon, modern CPUs)</option>
                            <option value="int8">int8 (Fastest, low memory usage)</option>
                            <option value="float32">float32 (Maximum precision, slower)</option>
                        </select>
                        <p class="text-xs mt-1 text-gray-500" id="compute-type-note">
                            Note: Currently running in CPU mode on all devices including Apple Silicon.<br>
                            For Apple Silicon: float16 is recommended.
                        </p>
                    </div>
                </div>

                <!-- Batch size option (only shown when MLX backend is selected) -->
                <div id="batch-size-container" class="hidden">
                    <label for="batch_size" class="block text-sm font-medium text-gray-700 mb-1">Batch Size (MLX
                        only)</label>
                    <input type="number" id="batch_size" name="batch_size" value="12" min="1" max="32"
                        class="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                    <p class="text-xs mt-1 text-gray-500">
                        Higher values process more data in parallel (faster), but use more memory.<br>
                        Recommended: 12 for medium models, 8 for large models, 16+ for small models.
                    </p>
                </div>

                <button type="submit" id="submit-button"
                    class="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed">
                    Transcribe Audio
                </button>
            </form>
        </div>

        <div id="result-container" class="bg-white rounded-lg shadow-md p-6 mb-8 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-800">Transcription Result</h2>
                <div>
                    <button id="export-txt"
                        class="px-3 py-1 bg-blue-100 text-blue-800 rounded-md text-sm hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        Export TXT
                    </button>
                    <button id="export-srt"
                        class="ml-2 px-3 py-1 bg-blue-100 text-blue-800 rounded-md text-sm hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        Export SRT
                    </button>
                    <button id="export-json"
                        class="ml-2 px-3 py-1 bg-blue-100 text-blue-800 rounded-md text-sm hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        Export JSON
                    </button>
                </div>
            </div>

            <!-- Device info display -->
            <div id="device-info" class="mb-4 p-3 bg-gray-100 rounded-md text-sm">
                <h3 class="font-medium mb-1">Processing Info</h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-2">
                    <div>
                        <span class="text-gray-600">Backend:</span>
                        <span id="backend-type" class="font-medium"></span>
                    </div>
                    <div>
                        <span class="text-gray-600">Device:</span>
                        <span id="device-type" class="font-medium"></span>
                    </div>
                    <div>
                        <span class="text-gray-600">Acceleration:</span>
                        <span id="acceleration-type" class="font-medium"></span>
                    </div>
                    <div>
                        <span class="text-gray-600">Model:</span>
                        <span id="model-type" class="font-medium"></span>
                    </div>
                </div>
            </div>

            <div class="overflow-y-auto max-h-[60vh] p-4 bg-gray-50 rounded-md">
                <div id="segments-container"></div>
            </div>
        </div>

        <div id="loading"
            class="hidden fixed top-0 left-0 w-full h-full bg-black bg-opacity-50 flex items-center justify-center z-10">
            <div class="bg-white p-6 rounded-lg shadow-lg text-center" style="min-width: 300px;">
                <div class="loading-spinner mx-auto mb-4"></div>
                <p id="loading-stage" class="text-gray-700 font-medium">Processing your audio...</p>
                <div class="w-full bg-gray-200 rounded-full h-2.5 my-4 dark:bg-gray-700">
                    <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                <p id="progress-percentage" class="text-sm text-blue-600 font-medium mb-2">0%</p>
                <div class="flex justify-between text-xs text-gray-500 mt-1">
                    <span id="memory-usage">Memory: 0 MB</span>
                    <span id="elapsed-time">Time: 0s</span>
                </div>
                <p class="text-sm text-gray-500 mt-3">This may take a few minutes depending on file size.</p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const dropArea = document.getElementById('drop-area');
            const fileInput = document.getElementById('file-input');
            const browseFiles = document.getElementById('browse-files');
            const uploadForm = document.getElementById('upload-form');
            const submitButton = document.getElementById('submit-button');
            const resultContainer = document.getElementById('result-container');
            const segmentsContainer = document.getElementById('segments-container');
            const loading = document.getElementById('loading');
            const exportTxt = document.getElementById('export-txt');
            const exportSrt = document.getElementById('export-srt');
            const exportJson = document.getElementById('export-json');
            const backendSelect = document.getElementById('backend');
            const modelSelect = document.getElementById('model_name');
            const batchSizeContainer = document.getElementById('batch-size-container');
            const maxSpeakersContainer = document.getElementById('max-speakers-container');
            const diarizationNote = document.getElementById('diarization-note');
            const computeTypeNote = document.getElementById('compute-type-note');

            // Initialize with default compute type based on device
            const isAppleSilicon = document.getElementById('backend-container').classList.contains('hidden') ? false : true;
            if (isAppleSilicon) {
                document.getElementById('compute_type').value = 'float16';
            } else {
                document.getElementById('compute_type').value = 'int8';
            }

            let transcriptionData = null;

            // Add MLX-specific models when MLX backend is selected
            if (backendSelect) {
                backendSelect.addEventListener('change', function () {
                    if (this.value === 'mlx') {
                        // Show batch size option and update model options
                        batchSizeContainer.classList.remove('hidden');
                        diarizationNote.classList.remove('hidden');

                        // Update compute type note for MLX
                        computeTypeNote.innerHTML = 'For MLX: float16=None (no quantization), int8=8bit quantization';

                        // Add distilled models specific to MLX
                        const currentValue = modelSelect.value;
                        // Clear existing options
                        while (modelSelect.options.length > 0) {
                            modelSelect.remove(0);
                        }

                        // Add MLX-specific options including distilled models
                        const mlxModels = [
                            { value: 'tiny', text: 'tiny (fastest, least accurate)' },
                            { value: 'base', text: 'base' },
                            { value: 'small', text: 'small' },
                            { value: 'distil-small.en', text: 'distil-small.en (faster English)' },
                            { value: 'medium', text: 'medium' },
                            { value: 'distil-medium.en', text: 'distil-medium.en (faster English)' },
                            { value: 'large', text: 'large' },
                            { value: 'large-v2', text: 'large-v2' },
                            { value: 'distil-large-v2', text: 'distil-large-v2 (faster)' },
                            { value: 'large-v3', text: 'large-v3' },
                            { value: 'distil-large-v3', text: 'distil-large-v3 (faster)' }
                        ];

                        mlxModels.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.value;
                            option.text = model.text;
                            if (model.value === currentValue ||
                                (currentValue === 'large-v2' && model.value === 'distil-large-v2')) {
                                option.selected = true;
                            }
                            modelSelect.appendChild(option);
                        });
                    } else {
                        // Hide batch size option and restore original model options
                        batchSizeContainer.classList.add('hidden');
                        diarizationNote.classList.add('hidden');

                        // Restore compute type note for WhisperX
                        computeTypeNote.innerHTML = 'Note: Currently running in CPU mode on all devices including Apple Silicon.<br>' +
                            'For Apple Silicon: float16 is recommended.';

                        // Restore original whisperx models
                        const currentValue = modelSelect.value;
                        // Clear existing options
                        while (modelSelect.options.length > 0) {
                            modelSelect.remove(0);
                        }

                        // Add standard WhisperX options
                        const whisperxModels = [
                            { value: 'tiny', text: 'tiny (fastest, least accurate)' },
                            { value: 'base', text: 'base' },
                            { value: 'small', text: 'small' },
                            { value: 'medium', text: 'medium' },
                            { value: 'large-v2', text: 'large-v2 (slowest, most accurate)' },
                            { value: 'large-v3', text: 'large-v3 (newest model)' }
                        ];

                        whisperxModels.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.value;
                            option.text = model.text;
                            if (model.value === currentValue ||
                                (currentValue.startsWith('distil-') && model.value === currentValue.replace('distil-', ''))) {
                                option.selected = true;
                            }
                            modelSelect.appendChild(option);
                        });
                    }
                });
            }

            // Handle drag and drop events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });

            function highlight() {
                dropArea.classList.add('highlight');
            }

            function unhighlight() {
                dropArea.classList.remove('highlight');
            }

            dropArea.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                fileInput.files = files;
                updateFileLabel(files[0].name);
            }

            browseFiles.addEventListener('click', function () {
                fileInput.click();
            });

            fileInput.addEventListener('change', function () {
                if (fileInput.files.length > 0) {
                    updateFileLabel(fileInput.files[0].name);
                }
            });

            function updateFileLabel(filename) {
                const fileInfo = document.createElement('div');
                fileInfo.classList.add('mt-4', 'text-sm', 'text-gray-700');
                fileInfo.innerHTML = `
                                <div class="flex items-center justify-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-500 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                                    </svg>
                                    <span>${filename}</span>
                                </div>
                            `;

                // Remove previous file info if exists
                const previousFileInfo = dropArea.querySelector('div.mt-4');
                if (previousFileInfo) {
                    previousFileInfo.remove();
                }

                dropArea.appendChild(fileInfo);
            }

            // Add progress polling
            let progressInterval = null;

            function startProgressPolling() {
                // Reset progress elements
                document.getElementById('progress-bar').style.width = '0%';
                document.getElementById('progress-percentage').textContent = '0%';
                document.getElementById('loading-stage').textContent = 'Processing your audio...';
                document.getElementById('memory-usage').textContent = 'Memory: 0 MB';
                document.getElementById('elapsed-time').textContent = 'Time: 0s';

                // Start polling for progress updates
                progressInterval = setInterval(fetchProgress, 500);
            }

            function stopProgressPolling() {
                if (progressInterval) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
            }

            function fetchProgress() {
                fetch('/progress')
                    .then(response => response.json())
                    .then(data => {
                        // Update progress bar
                        const progressBar = document.getElementById('progress-bar');
                        const progressPercent = document.getElementById('progress-percentage');
                        const loadingStage = document.getElementById('loading-stage');
                        const memoryUsage = document.getElementById('memory-usage');
                        const elapsedTime = document.getElementById('elapsed-time');

                        // Update progress percentage
                        progressBar.style.width = `${data.progress}%`;
                        progressPercent.textContent = `${data.progress}%`;

                        // Update current stage
                        if (data.current_stage) {
                            loadingStage.textContent = data.current_stage;
                        }

                        // Update memory usage
                        if (data.memory_usage > 0) {
                            memoryUsage.textContent = `Memory: ${Math.round(data.memory_usage)} MB`;
                        }

                        // Update elapsed time
                        if (data.elapsed_time > 0) {
                            const seconds = Math.round(data.elapsed_time);
                            elapsedTime.textContent = `Time: ${seconds}s`;
                        }

                        // If status is complete or error, we can stop polling
                        if (data.status === 'complete' || data.status === 'error') {
                            stopProgressPolling();
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching progress:', error);
                    });
            }

            uploadForm.addEventListener('submit', function (e) {
                e.preventDefault();

                if (!fileInput.files.length) {
                    alert('Please select an audio file first.');
                    return;
                }

                const formData = new FormData(uploadForm);

                submitButton.disabled = true;
                loading.classList.remove('hidden');
                resultContainer.classList.add('hidden');

                // Start progress polling
                startProgressPolling();

                fetch('/upload', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => response.json())
                    .then(data => {
                        // Stop progress polling
                        stopProgressPolling();

                        if (data.error) {
                            throw new Error(data.error);
                        }

                        transcriptionData = data.result;
                        displayTranscription(transcriptionData);

                        // Display device information
                        if (data.device_info) {
                            document.getElementById('backend-type').textContent = data.device_info.backend || 'Unknown';
                            document.getElementById('device-type').textContent = data.device_info.device || 'Unknown';
                            document.getElementById('acceleration-type').textContent = data.device_info.acceleration || 'Unknown';
                            document.getElementById('model-type').textContent = data.device_info.model || 'Unknown';

                            // Add a class to highlight GPU acceleration
                            if (data.device_info.acceleration && data.device_info.acceleration.includes('GPU')) {
                                document.getElementById('acceleration-type').classList.add('text-green-600');
                            } else {
                                document.getElementById('acceleration-type').classList.add('text-yellow-600');
                            }
                        }

                        resultContainer.classList.remove('hidden');

                        // Scroll to results
                        resultContainer.scrollIntoView({ behavior: 'smooth' });
                    })
                    .catch(error => {
                        // Stop progress polling on error
                        stopProgressPolling();
                        alert('Error: ' + error.message);
                    })
                    .finally(() => {
                        submitButton.disabled = false;
                        loading.classList.add('hidden');
                    });
            });

            function displayTranscription(data) {
                segmentsContainer.innerHTML = '';

                data.segments.forEach((segment, index) => {
                    const segmentDiv = document.createElement('div');
                    segmentDiv.classList.add('mb-6');

                    const headerDiv = document.createElement('div');
                    headerDiv.classList.add('flex', 'justify-between', 'mb-2');

                    const speakerInfo = segment.speaker ? `<span class="font-medium text-purple-700">Speaker ${segment.speaker}</span>` : '';

                    headerDiv.innerHTML = `
                                    <div class="flex items-center">
                                        <span class="text-sm font-medium text-gray-500">${formatTime(segment.start)} → ${formatTime(segment.end)}</span>
                                        ${speakerInfo ? `<span class="ml-3">${speakerInfo}</span>` : ''}
                                    </div>
                                    <span class="text-xs text-gray-400">Segment ${index + 1}</span>
                                `;

                    const contentDiv = document.createElement('div');
                    contentDiv.classList.add('text-gray-800', 'leading-relaxed');

                    // Add words with timestamps if available
                    if (segment.words && segment.words.length > 0) {
                        segment.words.forEach(word => {
                            const wordSpan = document.createElement('span');
                            wordSpan.classList.add('word', 'inline-block', 'px-0.5', 'cursor-pointer');
                            wordSpan.innerHTML = word.word + ' ';
                            wordSpan.title = `${formatTime(word.start)} → ${formatTime(word.end)}`;

                            // Add click handler to show exact timing
                            wordSpan.addEventListener('click', function () {
                                alert(`Word: "${word.word}"\nStart: ${formatTime(word.start)}\nEnd: ${formatTime(word.end)}`);
                            });

                            contentDiv.appendChild(wordSpan);
                        });
                    } else {
                        contentDiv.textContent = segment.text;
                    }

                    segmentDiv.appendChild(headerDiv);
                    segmentDiv.appendChild(contentDiv);
                    segmentsContainer.appendChild(segmentDiv);
                });
            }

            function formatTime(seconds) {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);

                return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            }

            // Export functionality
            exportTxt.addEventListener('click', function () {
                if (!transcriptionData) return;

                let content = '';
                transcriptionData.segments.forEach(segment => {
                    if (segment.speaker) {
                        content += `[Speaker ${segment.speaker}] `;
                    }
                    content += `${segment.text}\n\n`;
                });

                downloadFile('transcript.txt', content, 'text/plain');
            });

            exportSrt.addEventListener('click', function () {
                if (!transcriptionData) return;

                let content = '';
                transcriptionData.segments.forEach((segment, index) => {
                    const startTime = formatSrtTime(segment.start);
                    const endTime = formatSrtTime(segment.end);
                    const speakerPrefix = segment.speaker ? `[Speaker ${segment.speaker}] ` : '';

                    content += `${index + 1}\n`;
                    content += `${startTime} --> ${endTime}\n`;
                    content += `${speakerPrefix}${segment.text}\n\n`;
                });

                downloadFile('transcript.srt', content, 'text/plain');
            });

            exportJson.addEventListener('click', function () {
                if (!transcriptionData) return;

                const content = JSON.stringify(transcriptionData, null, 2);
                downloadFile('transcript.json', content, 'application/json');
            });

            function formatSrtTime(seconds) {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);

                return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
            }

            function downloadFile(filename, content, contentType) {
                const blob = new Blob([content], { type: contentType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });
    </script>
</body>

</html>